{"version":3,"sources":["lib/ipfs.ts","lib/wallet_session.ts","lib/algorand.ts","lib/metadata.ts","MediaDisplay.tsx","App.tsx","index.tsx","lib/nft.ts"],"names":["getMimeTypeFromIpfs","url","a","req","Request","method","fetch","resp","ctype","headers","get","getMetaFromIpfs","blob","body","text","parsed","JSON","parse","Metadata","WalletSession","network","accounts","defaultAccount","connector","this","WalletConnect","bridge","qrcodeModal","WalletConnectQRCodeModal","cb","connected","createSession","on","error","payload","params","Promise","resolve","reconn","setInterval","clearInterval","connect","killSession","isConnected","txns","defaultAddress","getDefaultAccount","txnsToSign","map","txn","encodedTxn","Buffer","from","algosdk","encodeUnsignedTransaction","toString","encodeAddress","publicKey","signers","request","formatJsonRpcRequest","sendCustomRequest","result","element","idx","txID","Uint8Array","config","Conf","client","Algodv2","algod","token","host","port","iface","ABIInterface","ABIdef","getMethodByName","name","m","methods","find","mt","undefined","Error","getToken","asset_id","getAssetByID","do","countRemaining","app_addr","getApplicationAddress","appId","accountAssetInformation","ainfo","sendWait","stxns","sendRawTransaction","txId","waitForConfirmation","getAirdropTxns","sender","signer","makeBasicAccountTransactionSigner","getTransactionParams","sp","atc","AtomicTransactionComposer","addTransaction","makeAssetTransferTxnWithSuggestedParamsFromObject","assetIndex","to","suggestedParams","amount","addMethodCall","appID","methodArgs","buildGroup","tws","getTypeFromMimeType","filetype","split","type","omitRawAndEmpty","k","v","args","_raw","description","image","decimals","unitName","image_integrity","image_mimetype","reserve","background_color","external_url","external_url_integrity","external_url_mimetype","animation_url","animation_url_integrity","animation_url_mimetype","extra_metadata","localization","properties","Object","assign","fmt","hasOwnProperty","hash","sha256","create","update","digest","md_blob","Blob","JSON_TYPE","File","METADATA_FILE","stringify","mimeType","t","MediaDisplay","props","media","id","controls","src","mediaSrc","alt","className","PromptAppNav","Classes","DIALOG_BODY","style","borderRadius","margin","href","isIOS","intent","large","minimal","outlined","rightIcon","App","React","useState","loading","setLoading","wallet","setConnected","remaining","setRemaining","setAssetId","nft","setNFT","audio_ref","useRef","document","getElementById","window","addEventListener","location","aid","parseInt","isNaN","useEffect","NFT","fromAssetId","then","cnt","links","assets","aidx","current","play","signTxn","signed","stxn","pause","display","mediaURL","metadata","asset_name","content","elevation","Elevation","TWO","paddingRight","onClick","triggerDrop","hidden","ref","isOpen","ReactDOM","StrictMode","ARC3_URL_SUFFIX","resolveProtocol","endsWith","slice","length","chunks","ipfsGateway","Token","metadataHash","total","creator","manager","clawback","freeze","defaultFrozen","p","index","md","urlMimeType","valid","substring","assetId","fromToken","fromParams"],"mappings":"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","file":"static/js/main.65850759.chunk.js","sourcesContent":["import {Metadata} from './metadata'\n\nexport async function getMimeTypeFromIpfs(url: string): Promise<string> {\n    const req = new Request(url, { method:\"HEAD\" })\n    const resp = await fetch(req)\n    const ctype = resp.headers.get(\"Content-Type\")\n    return ctype?ctype:\"\"\n}\n\nexport async function getMetaFromIpfs(url: string): Promise<Metadata> {\n    const req = new Request(url)\n    const resp = await fetch(req)\n    const body = await resp.blob()\n    const text = await body.text()\n    const parsed = JSON.parse(text)\n    return new Metadata({\"_raw\":text, ...parsed}) \n}","import algosdk, { Transaction, TransactionParams } from \"algosdk\";\n\nimport WalletConnect from \"@walletconnect/client\";\nimport WalletConnectQRCodeModal from \"algorand-walletconnect-qrcode-modal\";\n\nimport { formatJsonRpcRequest } from \"@json-rpc-tools/utils\";\n\n\ninterface SignedTxn {\n    txID: string\n    blob: Uint8Array\n};\n\nexport default class WalletSession {\n  accounts: string[];\n  defaultAccount: number;\n  network: string;\n  connector: WalletConnect;\n\n  constructor(network: string) {\n    this.accounts = [];\n    this.defaultAccount = 0;\n    this.network = network;\n    this.connector = new WalletConnect({\n        bridge : \"https://bridge.walletconnect.org\",\n        qrcodeModal: WalletConnectQRCodeModal,\n    });\n  }\n\n  async connect(cb: any): Promise<boolean> {\n    // Check if connection is already established\n    if (this.connector.connected) return true;\n\n    this.connector.createSession();\n\n    this.connector.on(\"connect\", (error, payload) => {\n      if (error) {\n        throw error;\n      }\n      const { accounts } = payload.params[0];\n      this.accounts = accounts;\n      cb(accounts);\n    });\n\n    this.connector.on(\"session_update\", (error, payload) => {\n      if (error) {\n        throw error;\n      }\n      const { accounts } = payload.params[0];\n      this.accounts = accounts;\n      cb(accounts);\n    });\n\n    this.connector.on(\"disconnect\", (error, payload) => {\n      if (error) throw error;\n    });\n\n\n    return new Promise(resolve=>{\n      const reconn = setInterval(() => {\n        if (this.connector.connected) {\n          clearInterval(reconn);\n          resolve(true);\n          return;\n        }\n        this.connector.connect();\n      }, 100);\n    });\n  }\n\n  isConnected(): boolean {\n    return this.connector.connected;\n  }\n\n  disconnect() {\n    this.connector.killSession();\n  }\n\n  getDefaultAccount(): string {\n    if (!this.isConnected()) return \"\";\n    return this.connector.accounts[this.defaultAccount];\n  }\n\n  async signTxn(txns: Transaction[]): Promise<SignedTxn[]> {\n    const defaultAddress = this.getDefaultAccount();\n    const txnsToSign = txns.map((txn) => {\n      const encodedTxn = Buffer.from(\n        algosdk.encodeUnsignedTransaction(txn)\n      ).toString(\"base64\");\n\n      if (algosdk.encodeAddress(txn.from.publicKey) !== defaultAddress)\n        return { txn: encodedTxn, signers: [] };\n      return { txn: encodedTxn };\n    });\n\n    const request = formatJsonRpcRequest(\"algo_signTxn\", [txnsToSign]);\n\n    const result: string[] = await this.connector.sendCustomRequest(request);\n\n    return result.map((element, idx) => {\n      return element\n        ? {\n            txID: txns[idx].txID(),\n            blob: new Uint8Array(Buffer.from(element, \"base64\")),\n          }\n        : {\n            txID: txns[idx].txID(),\n            blob: new Uint8Array(),\n          };\n    });\n  }\n\n}","import algosdk from 'algosdk'\nimport ABIdef from \"./abi.json\"\nimport Conf from './config.json'\n//import Conf from './sb_config.json'\n\ninterface configuration {\n    appId: number\n    assets: number[]\n    ipfsGateway: string\n    algod: {\n        network: string\n        host: string\n        token: string\n        port: string \n    }\n}\n\n\nexport const config = Conf as configuration\n\nconst client = new algosdk.Algodv2(config.algod.token, config.algod.host, config.algod.port)\nconst iface = new algosdk.ABIInterface({...ABIdef})\n\n// Utility function to return an ABIMethod by its name\nfunction getMethodByName(name: string): algosdk.ABIMethod  {\n    const m = iface.methods.find((mt: algosdk.ABIMethod)=>{ return mt.name===name })\n    if(m === undefined)\n        throw Error(\"Method undefined: \"+name)\n    return m\n}\n\nexport async function getToken(asset_id: number): Promise<any>{\n    return await client.getAssetByID(asset_id).do()\n}\n\nexport async function countRemaining(asset_id: number): Promise<number> {\n    const app_addr = algosdk.getApplicationAddress(config.appId)\n    const ainfo = await client.accountAssetInformation(app_addr, asset_id).do()\n    return ainfo['asset-holding']['amount']\n}\n\nexport async function sendWait(stxns: Uint8Array[]): Promise<any> {\n    const {txId} = await client.sendRawTransaction(stxns).do()\n    const result = await algosdk.waitForConfirmation(client, txId, 2)\n    return result\n}\n\nexport async function getAirdropTxns(asset_id: number, sender: string): Promise<algosdk.Transaction[]> {\n    // Empty signer, just a placeholder\n    const signer = algosdk.makeBasicAccountTransactionSigner({} as algosdk.Account)\n    // Build transaction group\n    const sp = await client.getTransactionParams().do()\n    const atc = new algosdk.AtomicTransactionComposer()\n    // Opt into asset\n    atc.addTransaction({\n        txn: algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n            assetIndex: asset_id,\n            from: sender,\n            to: sender,\n            suggestedParams: sp,\n            amount: 0\n        }),\n        signer: signer\n    })\n    // Method call to drop the asset\n    atc.addMethodCall({\n        appID: config.appId, \n        method: getMethodByName(\"drop\"), \n        sender: sender, \n        suggestedParams: sp,\n        methodArgs:[asset_id],\n        signer: signer \n    })\n    // Dump transaction array\n    return atc.buildGroup().map((tws)=>{ return tws.txn})\n}","import {Token, JSON_TYPE, METADATA_FILE} from './nft'\nimport { sha256 } from 'js-sha256'\n\nexport type Properties = {\n    [key: string]: string | number\n}\n\nexport type LocalizationIntegrity = {\n    [key: string]: string\n}\n\nexport type Localization = {\n    uri: string\n    default: string\n    locales: string[]\n    integrity?: LocalizationIntegrity\n}\n\n// Just takes the first chunk of the mimetype (the type)\nexport function getTypeFromMimeType(filetype: string): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [type, _] = filetype.split(\"/\")\n    return type\n}\n\nfunction omitRawAndEmpty(k:any,v:any){\n    if(k === \"_raw\") return undefined;\n    if(v === \"\") return undefined;\n    return v\n}\n\nexport class Metadata {\n    _raw: string | undefined = undefined\n\n    name: string = \"\"\n    description: string = \"\"\n\n    image: string = \"\"\n    decimals?: number = 0\n    unitName?: string = \"\"\n\n    image_integrity?: string = \"\"\n    image_mimetype?: string = \"\"\n\n    reserve?: string = \"\"\n\n    background_color?: string = \"\"\n\n    external_url?: string = \"\"\n    external_url_integrity?: string = \"\"\n    external_url_mimetype?: string = \"\"\n\n    animation_url?: string = \"\"\n    animation_url_integrity?: string = \"\"\n    animation_url_mimetype?: string = \"\"\n\n    extra_metadata?: string = \"\"\n\n    localization?: Localization\n\n    properties?: Properties\n\n    constructor(args: any = {}) { Object.assign(this, args) }\n\n    toHash(fmt: Boolean = false): Uint8Array {\n        if(this.hasOwnProperty(\"extra_metadata\")){\n            //TODO\n            //am = SHA-512/256(\"arc0003/am\" || SHA-512/256(\"arc0003/amj\" || content of JSON metadata file) || e)\n        }\n\n        if(this._raw === undefined)\n            this._raw = this.toString(false)\n\n        const hash = sha256.create();\n        fmt ? hash.update(this.toString(false)):hash.update(this._raw);\n        return new Uint8Array(hash.digest())\n    }\n\n    valid(): boolean {\n        return this.image !== \"\" || this.animation_url !== \"\" || this.external_url !== \"\"\n    }\n\n    toFile(): File {\n        const md_blob = new Blob([this.toString()], { type: JSON_TYPE })\n        return new File([md_blob], METADATA_FILE)\n    }\n\n    toString(fmt: Boolean = false): string {\n        if(this._raw === undefined) this._raw = JSON.stringify({...this}, omitRawAndEmpty)\n        return JSON.stringify(JSON.parse(this._raw) , omitRawAndEmpty, fmt?2:0)\n    }\n\n    mimeType(): string {\n        if(this.animation_url_mimetype) return this.animation_url_mimetype;\n        if(this.external_url_mimetype) return this.external_url_mimetype;\n        return this.image_mimetype?this.image_mimetype:\"\"\n    }\n\n    mediaType(): string {\n        return getTypeFromMimeType(this.mimeType())\n    }\n\n    mediaURL(): string {\n        return this.animation_url?this.animation_url:this.image;\n    }\n\n    static fromToken(t: Token){\n        return new Metadata({name:t.name, image: t.url, decimals: t.decimals, reserve: t.reserve })\n    }\n\n}\n","import { getTypeFromMimeType } from \"./lib/metadata\"\n\ntype MediaDisplayProps = {\n    mimeType: string\n    mediaSrc: string | undefined\n}\n\nexport function MediaDisplay(props: MediaDisplayProps){\n    const type = getTypeFromMimeType(props.mimeType)\n\n    let media = <div></div>\n    switch(type) {\n        case \"audio\":\n           media = (\n                <audio id=\"uploaded-media\" controls>\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </audio>\n            )\n            break;\n        case \"video\":\n            media = (\n                <video id=\"uploaded-media\" controls>\n                    <source src={props.mediaSrc} type={props.mimeType} />\n                </video>\n            )\n            break;\n        default:\n            media = (\n                <img id=\"uploaded-media\" alt=\"NFT\" src={props.mediaSrc} />\n            )\n    }\n\n    return (\n        <div className='media-display content' >\n            {media}\n        </div>\n    )\n}","import React from 'react';\nimport { config, getAirdropTxns, sendWait, countRemaining } from './lib/algorand'\nimport WalletSession from \"./lib/wallet_session\"\nimport { AnchorButton, Dialog, Card, Button, Elevation, Classes } from \"@blueprintjs/core\"\nimport { MobileView, isIOS } from 'react-device-detect'\nimport {MediaDisplay} from './MediaDisplay'\nimport { NFT } from './lib/nft';\n\nfunction App() {\n\n  const [loading, setLoading] = React.useState(false)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [wallet, setWallet] = React.useState(new WalletSession(config.algod.network))\n  const [connected, setConnected] = React.useState(false)\n  const [remaining, setRemaining] = React.useState(0)\n  const [asset_id, setAssetId] = React.useState<number>(0)\n  const [nft, setNFT] = React.useState<NFT|undefined>(undefined)\n\n  // This is the hack that makes iOS not kill our websocket with WalletConnect\n  const audio_ref = React.useRef<HTMLAudioElement>(document.getElementById('hack') as HTMLAudioElement);\n\n  window.addEventListener(\"hashchange\", () => {\n    const hash = window.location.hash\n    const aid = hash === \"\" ? 0 : parseInt(hash.split(\"#\")[1])\n    setAssetId(isNaN(aid) ? 0 : aid);\n  })\n\n\n  const hash = window.location.hash\n  const aid = hash === \"\" ? 0 : parseInt(hash.split(\"#\")[1])\n\n\n  React.useEffect(() => { setConnected(wallet.isConnected()) }, [wallet])\n  React.useEffect(() => {\n\n    if(aid !== 0 && ! isNaN(aid)){\n      setAssetId(aid);\n    }\n\n    if (asset_id === 0) return;\n\n    NFT.fromAssetId(asset_id).then((nft)=>{\n      setNFT(nft)\n    })\n\n    countRemaining(asset_id).then((cnt: number) => {\n      setRemaining(cnt)\n    })\n\n  }, [loading, asset_id])\n\n\n  // If no asset id in path, just dump links\n  if (asset_id === 0) {\n    const links = config.assets.map((aidx)=>{\n        return <a key={aidx} href={'#' + aidx.toString()}>{aidx}</a>\n    })\n\n    return (\n      <div className='container'>\n        {links}\n      </div>\n    )\n  }\n\n  async function triggerDrop(asset_id: number) {\n    audio_ref.current?.play()\n    setLoading(true)\n\n    const txns = await getAirdropTxns(asset_id, wallet.getDefaultAccount())\n    const signed = await wallet.signTxn(txns)\n    await sendWait(signed.map((stxn) => { return stxn.blob }))\n\n    setLoading(false)\n    audio_ref.current?.pause()\n  }\n\n  async function connect() {\n    audio_ref.current?.play()\n    wallet.connect(() => {\n      setConnected(true)\n      audio_ref.current?.pause()\n    })\n  }\n\n  const display = nft === undefined ? <></>: <MediaDisplay\n    mediaSrc={nft.mediaURL()}\n    mimeType={nft.metadata.mimeType()}\n  />\n\n  let asset_name = nft=== undefined? asset_id.toString():nft.name()\n  if(asset_name === \"\"){\n    asset_name = \"tbd asset name\"\n  }\n\n\n  const content = connected ? (\n    <Card elevation={Elevation.TWO}>\n      <h2>{asset_name}</h2>\n      <div className='content'>\n        {display}\n      </div>\n      <div className='action'>\n        <h3 style={{paddingRight:'10px'}}>{remaining} Left</h3>\n        <Button\n          intent='success'\n          onClick={() => { triggerDrop(asset_id) }}\n          key={'asset-' + asset_name}\n          text={'Gib me ' + asset_name}\n          loading={loading}\n        />\n\n      </div>\n    </Card>\n  ) : <Button onClick={connect}>Connect</Button>\n\n  return (\n    <div className=\"container\">\n      <div className='content'>\n        {content}\n      </div>\n      <audio hidden id='hack' ref={audio_ref} src='https://github.com/anars/blank-audio/blob/master/30-seconds-of-silence.mp3?raw=true' ></audio>\n      <PromptAppNav isOpen={loading} />\n    </div>\n  );\n}\n\ninterface PromptAppNavProps {\n  isOpen: boolean\n}\nfunction PromptAppNav(props: PromptAppNavProps) {\n  return (\n    <Dialog {...props} >\n      <div className={Classes.DIALOG_BODY}>\n        <div className='container'>\n          <div className='content'>\n            <p>Open the Pera Wallet to approve the transaction then come back</p>\n          </div>\n          <MobileView>\n            <AnchorButton\n              style={{ borderRadius: '8px', margin: '20px 0px -30px' }}\n              text='Take me there'\n              href={isIOS ? \"algorand-wc://wc?uri=wc:00e46b69-d0cc-4b3e-b6a2-cee442f97188@1\" : \"wc:00e46b69-d0cc-4b3e-b6a2-cee442f97188@1\"}\n              intent=\"success\"\n              large={true}\n              minimal={true}\n              outlined={true}\n              rightIcon=\"double-chevron-right\"\n            />\n          </MobileView>\n        </div>\n      </div>\n    </Dialog>\n  )\n}\n\nexport default App;","import React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App  />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","import { getMetaFromIpfs, getMimeTypeFromIpfs } from './ipfs'\nimport { sha256 } from 'js-sha256'\nimport { Metadata } from './metadata'\nimport {config, getToken} from  './algorand'\n// import { CIDVersion } from 'multiformats'\n\n/*\n\nThe following is a class and metadata type to support the ARC-0003 standard\nset forth by the Algorand Foundation and Community\n\nhttps://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0003.md\n\n*/\n\nexport const ARC3_NAME_SUFFIX = '@arc3'\nexport const ARC3_URL_SUFFIX = '#arc3'\nexport const METADATA_FILE = 'metadata.json'\nexport const JSON_TYPE = 'application/json'\n\nexport function asaURL (cid: string): string { return ipfsURL(cid) + ARC3_URL_SUFFIX }\n\nexport function ipfsURL (cid: string): string { return 'ipfs://' + cid }\n\nexport function fileURL (cid: string, name: string): string { return config.ipfsGateway + cid + '/' + name }\n\nexport function resolveProtocol (url: string): string {\n\n    if (url.endsWith(ARC3_URL_SUFFIX))\n        url = url.slice(0, url.length - ARC3_URL_SUFFIX.length)\n\n    let chunks = url.split('://')\n\n    // No protocol specified, give up\n    if (chunks.length < 2) return url\n\n    //Switch on the protocol\n    switch (chunks[0]) {\n        case 'ipfs': //Its ipfs, use the configured gateway\n            return config.ipfsGateway + chunks[1]\n        case 'https': //Its already http, just return it\n            return url\n        // TODO: Future options may include arweave or algorand\n    }\n\n    return url\n}\n\nexport async function mediaIntegrity (file: File): Promise<string> {\n    const buff = await file.arrayBuffer()\n    const bytes = new Uint8Array(buff)\n    const hash = new Uint8Array(sha256.digest(bytes))\n    return 'sha256-' + Buffer.from(hash).toString('base64')\n}\n\nexport class Token {\n    id: number\n\n    name: string\n    unitName: string\n    url: string\n\n    metadataHash: string\n\n    total: number\n    decimals: number\n\n    creator: string\n\n    manager: string\n    reserve: string\n    clawback: string\n    freeze: string\n\n    defaultFrozen: boolean\n\n    constructor (t: any) {\n        this.id = t.id || 0\n        this.name = t.name || ''\n        this.unitName = t.unitName || ''\n        this.url = t.url || ''\n\n        this.metadataHash = t.metadataHash || ''\n\n        this.total = t.total || 0\n        this.decimals = t.decimals || 0\n\n        this.creator = t.creator || ''\n\n        this.manager = t.manager || ''\n        this.reserve = t.reserve || ''\n        this.clawback = t.clawback || ''\n        this.freeze = t.freeze || ''\n\n        this.defaultFrozen = t.defaultFrozen || false\n    }\n\n    static fromParams (t: any): Token {\n        const p = t.params\n        return new Token({\n            id: t.index,\n            name: p.name || '',\n            unitName: p['unit-name'] || '',\n            url: p.url || '',\n            metadataHash: p['metadata-hash'] || '',\n            total: p.total || 0,\n            decimals: p.decimals || 0,\n            creator: p.creator || '',\n            manager: p.manager || '',\n            reserve: p.reserve || '',\n            clawback: p.clawback || '',\n            freeze: p.freeze || '',\n            defaultFrozen: p['default-frozen'] || false,\n        }) as Token\n\n    }\n\n    valid (): boolean {\n        return this.id > 0 && this.total > 0 && this.url !== ''\n    }\n\n}\n\nexport class NFT {\n    token: Token | undefined = new Token({})\n    metadata: Metadata = new Metadata()\n\n    urlMimeType: string | undefined = undefined\n\n    constructor (md: Metadata, token?: Token, urlMimeType?: string) {\n        this.metadata = md\n        this.token = token\n        this.urlMimeType = urlMimeType\n    }\n\n    static async fromAssetId (assetId: number): Promise<NFT> {\n        return NFT.fromToken(await getToken(assetId))\n    }\n\n    static async fromToken (t: any): Promise<NFT> {\n        const token = Token.fromParams(t)\n        const url = resolveProtocol(token.url)\n\n        //TODO: provide getters for other storage options\n        // arweave? note field?\n\n        try {\n            const urlMimeType = await getMimeTypeFromIpfs(url)\n\n            switch (urlMimeType) {\n                case JSON_TYPE:\n                    return new NFT(await getMetaFromIpfs(url), token, urlMimeType)\n            }\n\n            return new NFT(Metadata.fromToken(token), token, urlMimeType)\n        } catch (error) {\n            return new NFT(new Metadata(), token)\n        }\n    }\n\n    valid (): boolean {\n        return this.token !== undefined && this.token.valid() && this.metadata.valid()\n    }\n\n    name (): string {\n        if (this.metadata.valid()) {\n            return this.metadata.name\n        }\n        if (this.token !== undefined && this.token.valid()) {\n            return this.token.name\n        }\n        return ''\n    }\n\n    id (): number {\n        return this.token !== undefined && this.token.valid() ? this.token.id : 0\n    }\n\n    mediaURL (): string {\n        if (!this.valid()) return 'https://dummyimage.com/640x360/fff/aaa'\n\n        // Try to resolve the protocol, if one is set\n        const url = resolveProtocol(this.metadata.mediaURL())\n\n        // If the url is different, we resolved it correctly\n        if (url !== this.metadata.mediaURL()) return url\n\n        // It may be a relative url stored within the same directory as the metadata file\n        // Lop off the METADATA_FILE bit and append image path\n        if (this.token === undefined) return url\n\n        if (this.token.url.endsWith(METADATA_FILE)) {\n            const dir = this.token.url.substring(0, this.token.url.length - METADATA_FILE.length)\n            return resolveProtocol(dir) + this.metadata.mediaURL()\n        }\n\n        // give up\n        return url\n    }\n}\n"],"sourceRoot":""}